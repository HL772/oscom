# Project Aurora 方法全量说明（全中文、细节版）

> 本文只讲“用了哪些方法，以及这些方法怎么实现”，不提任何代码路径、文件名或变量名。
> 目标：让没有内核背景的人也能理解“实现是怎么做出来的”。

---

## 1. 工程化与可复现的方法

### 1.1 一键化构建与测试
**怎么实现**
1) 把编译、打包、运行、测试拆成固定步骤。
2) 每一步都用同样的参数与默认值组织起来。
3) 所有步骤可以重复执行，保证结果一致。

**通俗解释**
把“手动输入一串命令”变成“按一个按钮就能跑完”，别人照着做也能得到同样结果。

### 1.2 分层架构
**怎么实现**
1) 把工程分成“应用层、内核服务层、通用库、硬件抽象层”。
2) 上层只调用下层提供的接口，不直接操作底层细节。
3) 下层不依赖上层，避免循环依赖。

**通俗解释**
像盖楼：地基、楼层、装修各司其职，装修不能直接改地基结构。

### 1.3 接口化解耦
**怎么实现**
1) 不同子系统之间只通过“统一接口”交互。
2) 接口只描述“能做什么”，不暴露“内部怎么做”。
3) 以后要替换某个模块，只要接口不变即可。

**通俗解释**
像插座与电器：插头规格一样，电器可以随便换。

### 1.4 过程可追溯
**怎么实现**
1) 设计阶段写清楚目标、取舍和方案。
2) 开发过程记录阶段性结论和问题。
3) 每次改动都能回溯到“为什么这样做”。

**通俗解释**
出现问题时能快速查到“当时怎么想的”。

---

## 2. 启动与平台初始化的方法

### 2.1 最早期引导
**怎么实现**
1) 关闭中断，防止初始化途中被打断。
2) 建立一个安全的临时栈。
3) 清空未初始化的数据区，避免脏数据。
4) 跳转到主入口，开始执行内核主流程。

**通俗解释**
先把工作台整理干净，再开始干活。

### 2.2 固件交接
**怎么实现**
1) 由固件负责把 CPU 置于可用状态。
2) 固件把控制权交给内核入口。

**通俗解释**
固件像“启动器”，先把车发动，再交给驾驶员。

### 2.3 设备树解析
**怎么实现**
1) 读取设备树中的内存范围。
2) 读取串口地址，建立早期输出通道。
3) 读取定时器频率，初始化时钟。
4) 读取设备地址与中断号，为驱动准备数据。

**通俗解释**
设备树就是“硬件说明书”。内核按说明书初始化硬件。

### 2.4 子系统初始化顺序
**怎么实现**
1) 先初始化日志输出，保证能看到启动信息。
2) 再初始化内存管理，后续模块才能分配内存。
3) 初始化中断控制与时钟，保证可以响应中断。
4) 初始化驱动，建立设备访问能力。
5) 初始化文件系统与用户态启动逻辑。

**通俗解释**
先把“水电”接好，再装“家具”。

---

## 3. 中断、异常与系统调用的方法

### 3.1 统一陷入入口
**怎么实现**
1) CPU 发生中断/异常时跳到统一入口。
2) 把所有寄存器与关键状态保存到一块内存中。
3) 保存完成后再进入“高级处理流程”。

**通俗解释**
发生中断时先“拍照”，处理完再按照片还原。

### 3.2 用户态切换与栈保护
**怎么实现**
1) 用户态程序有自己的栈，内核有自己的栈。
2) 陷入时切换到内核栈，避免用户栈不安全。
3) 返回用户态前再恢复用户栈。

**通俗解释**
进入内核就换“安全工作台”，离开时再回用户桌子。

### 3.3 系统调用分发
**怎么实现**
1) 用户态触发系统调用会进入陷入入口。
2) 内核读取调用号和参数。
3) 按调用号查表，跳到对应处理逻辑。
4) 执行结束把结果放回寄存器并返回。

**通俗解释**
像“服务台编号叫号”，找对应窗口办理业务。

### 3.4 定时器中断与抢占
**怎么实现**
1) 设置周期性时钟中断（tick）。
2) tick 到来时设置“需要调度”标记。
3) 在安全的时机切换任务。

**通俗解释**
像闹钟提醒“该换人用 CPU 了”。

### 3.5 外部中断处理
**怎么实现**
1) 中断控制器提供“哪个设备触发中断”的信息。
2) 内核读取这个信息，并交给对应驱动处理。
3) 处理完成后通知中断控制器“已处理”。

**通俗解释**
中断控制器像“总机”，把电话转接给正确的人。

### 3.6 写时复制的异常处理
**怎么实现**
1) 父子进程共享只读内存页。
2) 当其中一个写入时触发写入异常。
3) 内核分配新页，复制原内容，再允许写入。

**通俗解释**
先共用一本书，谁要写字就复制一份自己写。

---

## 4. 内存管理的方法

### 4.1 地址与页的抽象
**怎么实现**
1) 区分物理地址与虚拟地址。
2) 统一页大小，所有分配以页为单位。

**通俗解释**
像区分“地图坐标”和“真实地址”，避免混用。

### 4.2 分页映射
**怎么实现**
1) 内核建立多级页表结构。
2) 在页表中记录虚拟页到物理页的映射。
3) 访问时由硬件自动查页表完成转换。

**通俗解释**
像“多级目录”，先查总目录再查子目录。

### 4.3 早期身份映射
**怎么实现**
1) 启动早期使用“虚拟=物理”的映射。
2) 用较大的页覆盖内核内存范围。

**通俗解释**
前期用“直通路线”，简单可靠。

### 4.4 帧分配与回收
**怎么实现**
1) 初始化时记录可用物理内存范围。
2) 早期用“顺序取用”的方式分配。
3) 后期用“空闲列表”回收与重复利用。

**通俗解释**
先是“只拿不还”，稳定后再“借还管理”。

### 4.5 用户内存访问保护
**怎么实现**
1) 访问用户指针前先验证是否在合法地址范围。
2) 跨页访问时逐页检查权限。
3) 只有合法才允许读写。

**通俗解释**
不能随便让用户传地址“读内核机密”。

### 4.6 写时复制
**怎么实现**
1) 复制进程时把可写页降为只读。
2) 写入触发异常。
3) 分配新页并复制旧数据。
4) 更新页表权限为可写。

**通俗解释**
延迟分家，写的时候才复制。

### 4.7 缓存与地址同步
**怎么实现**
1) 修改页表后刷新地址缓存。
2) 写入代码页后刷新指令缓存。

**通俗解释**
让 CPU 看到最新的“地址表”和“指令内容”。

### 4.8 内核栈保护
**怎么实现**
1) 为每个任务分配独立内核栈。
2) 在栈边界放置保护页。

**通俗解释**
栈一旦越界就会触发异常，不会悄悄破坏内存。

---

## 5. 进程、任务与调度的方法

### 5.1 进程与任务分离
**怎么实现**
1) 进程保存资源（地址空间、文件表等）。
2) 任务保存执行状态（寄存器、栈等）。
3) 调度只针对任务，资源归属在进程。

**通俗解释**
进程是“容器”，任务是“工人”。

### 5.2 就绪队列与轮转调度
**怎么实现**
1) 就绪队列保存可运行任务。
2) 按顺序取出任务运行。
3) 时间片用完再放回队列末尾。

**通俗解释**
大家排队轮流使用 CPU。

### 5.3 阻塞等待与唤醒
**怎么实现**
1) 任务等待事件时从就绪队列移除。
2) 放入等待队列或睡眠队列。
3) 事件发生后再移回就绪队列。

**通俗解释**
等车的人去候车室，车来再排回队。

### 5.4 退出与回收
**怎么实现**
1) 子任务退出后进入“已退出但未回收”状态。
2) 父进程调用等待接口回收资源。

**通俗解释**
子进程退出留下“记录”，父进程负责清理。

---

## 6. 系统调用的实现方法（全量）

### 6.1 基础调用机制
**怎么实现**
1) 用户态通过特定指令触发系统调用。
2) 内核在陷入入口中读取调用号与参数。
3) 通过分发表找到对应处理逻辑。
4) 把结果返回用户态。

**通俗解释**
像拨打“内核服务热线”，接线员按号码分配业务员。

### 6.2 文件与目录相关方法
- **读写类**：
  - 实现思路：在文件句柄里保存当前位置，读写后更新位置。
  - 通俗解释：像在书里读写，读完页码前进。
- **随机读写**：
  - 实现思路：指定位置读写，不改变当前位置。
  - 通俗解释：像直接翻到某页读，不移动书签。
- **打开文件**：
  - 实现思路：先解析路径，再在文件系统中找到对应对象。
  - 通俗解释：先查目录，再拿到文件“身份证”。
- **目录枚举**：
  - 实现思路：让文件系统返回目录项列表。
  - 通俗解释：目录是“文件清单”。
- **文件信息**：
  - 实现思路：读取文件的大小、类型与权限等元信息。
  - 通俗解释：看文件的“说明书”。

### 6.3 进程与调度相关方法
- **创建子进程**：
  - 实现思路：复制地址空间并启用写时复制。
  - 通俗解释：先共享内存，写入时再复制。
- **等待子进程**：
  - 实现思路：父进程阻塞等待，子进程退出后唤醒。
  - 通俗解释：父母等孩子回家再统计结果。

### 6.4 内存相关方法
- **堆扩展**：
  - 实现思路：按页分配并更新“堆顶”。
- **映射内存**：
  - 实现思路：建立新的虚拟区域，按需分配物理页。

### 6.5 时间与睡眠
- **获取时间**：
  - 实现思路：用硬件计时器换算成时间单位。
- **睡眠**：
  - 实现思路：任务放入睡眠队列，到期唤醒。

### 6.6 并发与同步
- **等待/唤醒**：
  - 实现思路：以地址为键管理等待队列。
- **轮询**：
  - 实现思路：先检查就绪，再休眠一小段时间重复检查。

### 6.7 网络接口
- **建立连接与传输**：
  - 实现思路：将网络对象绑定到文件描述符，读写与阻塞一致化。

### 6.8 设备与系统信息
- **终端与系统信息**：
  - 实现思路：提供最小可用的占位信息，保证应用不崩溃。

---

## 7. 文件系统的方法（通俗说明）

### 7.1 统一文件系统接口
**怎么实现**
1) 抽象出“查找、读、写、列目录”等统一操作。
2) 不同文件系统只需要实现这些操作。

**通俗解释**
像“统一插座”，不同电器都能插。

### 7.2 路径解析与挂载
**怎么实现**
1) 先找到路径属于哪个挂载点。
2) 再在该文件系统内部解析。

**通俗解释**
先找“归属地”，再办事。

### 7.3 缓存与写回
**怎么实现**
1) 读取先进入内存缓存。
2) 写入先标记为脏数据。
3) 需要时统一刷回。

**通俗解释**
先写草稿，最后统一誊写到磁盘。

---

## 8. ext4 文件系统方法（超详细）

### 8.1 读取全局信息
- 读出文件系统的基本参数（块大小、inode 大小等）。
- 如果参数不符合要求则拒绝挂载。

### 8.2 组织结构定位
- 通过块组描述信息找到：
  - 块位图（哪些块空闲）
  - inode 位图（哪些 inode 空闲）
  - inode 表（inode 在哪里）

### 8.3 文件元信息读取
- 读取 inode 得到：
  - 文件类型与权限
  - 文件大小
  - 数据块指针

### 8.4 目录遍历
- 目录本质是一个“记录表”。
- 每条记录包含名称与记录长度。
- 通过记录长度逐条跳转。

### 8.5 文件读取
- 按逻辑块号查找物理块号。
- 如果是稀疏文件，没有映射就返回 0。

### 8.6 文件写入
- 写入时如果逻辑块不存在就分配新块。
- 写入完成后更新文件大小。

### 8.7 块分配方法
- 从位图中找第一个空闲位并置位。
- 返回该块号作为新分配块。

### 8.8 一致性取舍
- 不实现日志与复杂校验。
- 目的是先保证最小功能可用。

---

## 9. FAT32 文件系统方法

### 9.1 读取磁盘参数
- 解析 FAT32 头部参数，得到簇大小与 FAT 表位置。

### 9.2 文件读取
- 通过 FAT 表找到文件所有簇。
- 按簇顺序拼接出完整数据。

### 9.3 文件写入
- 扩展 FAT 链表并更新文件大小。

---

## 10. 驱动与设备方法

### 10.1 设备发现
- 扫描设备信息表，找到设备地址与中断号。

### 10.2 统一驱动流程
- 识别设备 → 初始化设备 → 处理中断。

### 10.3 中断与轮询混合
- 有中断优先用中断。
- 没有中断时定时轮询。

---

## 11. 网络方法

### 11.1 数据收发
- 网络设备提供收包/发包接口。

### 11.2 协议处理
- 协议栈负责解析包并转换为 socket 行为。

### 11.3 连接语义
- 非阻塞连接会先返回“正在连接”。
- 连接完成后再报告成功。

---

## 12. 异步执行器方法

- 采用固定容量的任务槽。
- 每次空闲时轮询推进任务。
- 任务可主动让出执行权。

---

## 13. 用户态应用与交互式验证方法

### 13.1 用户态测试程序
- 网络回显程序用于验证 socket 语义。
- 文件系统冒烟程序用于验证读写语义。

### 13.2 交互式 shell
- 提供常用命令，手工测试文件与目录。

### 13.3 应用适配路线
- 先采集系统调用，再补齐能力。

---

## 14. 测试与基准方法

- 分层测试：从小到大。
- 冒烟测试只看关键日志。
- 基准测试记录吞吐与延迟。

---

## 15. 调试与日志方法

- 串口日志用于早期调试。
- 远程调试用于断点与寄存器检查。
- 系统调用统计用于发现缺口。

---

## 16. 交付方法

- 把源码、文档、日志打包成可提交产物。

---

## 17. 未来方法（规划）

- 动态观测：运行时插入探针。
- 批量异步 I/O：减少系统调用开销。
- 用户态中断：提升实时性与效率。

---

## 18. 汇报版总结

这套内核的实现方法是：
**以脚本化保证可复现，以分层化保证可扩展，以最小可用路径打通启动、内存、调度、系统调用、文件系统与网络，并在此基础上逐步完善一致性与性能。**
